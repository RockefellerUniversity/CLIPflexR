---
title: "Processing reads, mapping, and building a count matrix"
author: "Kathryn Rozen-Gagnon, Ji-Dung Luo and Thomas Carroll"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{processing_to_matrix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=TRUE, message=FALSE}
baseDir <- "/Users/kathryn/Reprocess_all_paper_datasets/test_processing_vignette"
library(stringr)
library(CLIPflexR)
library(SummarizedExperiment)
library(GenomicRanges)
library(rtracklayer)
```

## Process standard/BrdU-CLIP libraries using CLIPflexR

This is an alternative to the CTK-only processing pipeline for CLIP data, and returns a peak matrix with genomic locations of peaks and counts in each peak by sample

##Initial processing and quality control

### Decompress fastq files
Use compressed fastq files as input; R-wrapped decompression function using bzip2.
[CLIPflexR documentation](decompress.html)

```{r decompress,echo=TRUE,eval=TRUE}
#define the path to your compressed fastq file(s)
#here we have one example fastq.gz generated by standard CLIP (linker ligations; KRG092419_S1_L001_R1_001.fastq.gz)
#and one example fastq.gz generated by BrdU-CLIP (KRG091819_S1_L001_R1_001.fastq.gz)
testFQ <- dir(baseDir, pattern = ".gz", full.names = TRUE)
testFQ
FqFile <- lapply(testFQ, decompress, overwrite=TRUE)
FqFile
```

### You can look at the quality of your data  **(wrapping FASTX's quality stats)**
Get quality statistics from your run using R-wrapped **fastx_quality_stats** [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastq_statistics_usage)
[CLIPflexR documentation](fastx_quality_stats.html)

```{r quality_stats,echo=TRUE,eval=TRUE, results  = "asis"}
#defaults are set for illumina quality encoding, minimum quality score of 20 for 80% of bases
stats <- lapply(FqFile, fastx_quality_stats)
stats
stats <- read.delim(stats[[1]],header = T, sep = "\t")
head(stats)
```

### Quality filter **(wrapping FastX's quality filter)**
Filtering fastq files using R-wrapped **fastq_quality_filter** from  [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastq_quality_filter_usage).
**qEncoding**: Quality encoding, default =  33 (corresponds to Illumina and Sanger quality scores); **minimumQuality**: minimum quality score to keep, default = 20. Only keep reads with quality score greater than this threshold. **minimumPercentOfRead**: minimum percent of bases that must have [-q] minimumQuality.
[CLIPflexR documentation](fastq_quality_filter.html)

```{r quality_filter,echo=TRUE,eval=TRUE}
FqFile_QF <- lapply(FqFile, fastq_quality_filter)
FqFile_QF
```

### Fastx_collapser **(wrapping FASTX's fastx_collapser)**
Collapse duplicate sequences into unique reads using R-wrapped **fastx_collapser** from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_collapser_usage.).
**qEncoding**: Quality encoding, default =  33 (corresponds to Illumina and Sanger quality scores).
[CLIPflexR documentation](fastx_collapser.html)

```{r collapse_PCR_duplicates,echo=TRUE,eval=TRUE}
coll_FqFile_QF <- lapply(FqFile_QF, fastx_collapser)
coll_FqFile_QF
```

##Follow these steps to process standard CLIP libraries generated by ligation  of 5'  and 3' linkers to RNAs

### De-multiplex samples **(wrapping FASTX's barcode splitter)**
De-multiplex samples by indices using R-wrapped **fastx_barcode_splitter** from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_barcode_splitter_usage).
**mismatches**: number of mismatches allowed in barcode sequence, 0 (default); **bcFile**: barcode file, see example below. 
[CLIPflexR documentation](fastx_barcode_splitter.html)

```{r std_split_samples,echo=TRUE,eval=TRUE, results  = "asis"}
#provide the path to your barcode file,  which must contain one sample name and its corresponding index sequence for  each line, and be tab delimited

#For example:
#Aag2_rIgG_Exp6A CGATG
#Aag2_rIgG_Exp6B TTAGG

BCfile <- dir(baseDir, pattern="BC",  full.names = TRUE)
BCfile <- grep("stats", BCfile, value =T, invert = T)
BCfile

#take standard libraries only
samples_split_std <- fastx_barcode_splitter(coll_FqFile_QF[[2]], bcFile = BCfile[[2]], verbose = TRUE)
#files will be written with a prefix appended for the run, and then the sample name given in the barcode file
#split samples will not have an extension but will be in FASTA format
samples_split_std

#sample_stats will also be written, and contain how many reads were extracted for each sample and the file name for that run ID
std_samples_stats <- read.delim(paste0(baseDir, "/KRG092419_BC_stats.txt"), header = T, sep =  "\t")
head(std_samples_stats)
```

### Now remove the 5' index, linker, and random barcode sequences **(wrapping CTK's stripBarcode.pl)**
Strip random barcodes/linkers with specific length from reads using R-wrapped **stripBarcode.pl** from [CTK](https://zhanglab.c2b2.columbia.edu/index.php/CTK_usage#stripBarcode.pl).
**linkerlength**: barcode length; **inputformat**: format of input sequences, fasta (default).
[CLIPflexR documentation](ctk_stripBarcode.html)

```{r std_strip_5prime,echo=TRUE,eval=TRUE}
samples_split_std_rm5 <- lapply(samples_split_std, ctk_stripBarcode, linkerlength = 27, inputFormat="fasta")
samples_split_std_rm5
```

### Now remove the 3' linker **(wrapping FASTX's clipper)**
Trimming 3'-end adapter sequences  using R-wrapped **fastx_clipper** function from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_clipper_usage).
**adaptor**: clip this sequence from the 3'-end of reads, "GTGTCAGTCACTTCCAGCGG" (default); **length**: minimum read length, only keep reads with length equal or greater then this threshold, 18 (default).
[CLIPflexR documentation](fastx_clipper.html)

```{r Std_clip_3prime,echo=TRUE,eval=TRUE}
samples_split_std_rm5_rm3 <- lapply(samples_split_std_rm5, fastx_clipper, length = 18, adaptor="GTGTCAGTCACTTCCAGCGG")
samples_split_std_rm5_rm3
```
###These reads are now ready to map to your genome

##Follow these steps to process BrdU-CLIP libraries (RT adds adaptor sequences, indices, and UMIs to RNAs)

###First strip random barcode sequences (UMI) from the 5' end of reads **(wrapping CTK's stripBarcode.pl)**
Strip random barcodes/linkers with specific length from reads using R-wrapped **stripBarcode.pl** from [CTK](https://zhanglab.c2b2.columbia.edu/index.php/CTK_usage#stripBarcode.pl).
**linkerlength**: barcode length; **inputformat**: format of input sequences. (fasta/fastq).
[CLIPflexR documentation](ctk_stripBarcode.html)

```{r BrdU_strip_5prime,echo=TRUE,eval=TRUE}
BrdU_rm5 <- ctk_stripBarcode(coll_FqFile_QF[[1]], linkerlength = 7, inputFormat="fasta")
BrdU_rm5
```

### De-multiplex samples **(wrapping FASTX's barcode splitter)**
De-multiplex samples by indices using R-wrapped **fastx_barcode_splitter** from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_barcode_splitter_usage).
**mismatches**: number of mismatches allowed in barcode sequence, 0 (default); **bcFile**: barcode file see example above. 
[CLIPflexR documentation](fastx_barcode_splitter.html)


```{r BrdU_split_samples,echo=TRUE,eval=TRUE, results="asis"}
samples_split_BrdU <- fastx_barcode_splitter(BrdU_rm5, bcFile = BCfile[[1]], verbose = TRUE)

#files will be written with a prefix appended for the run, and then the sample name given in the barcode file
#split samples will not have an extension but will be in FASTA format
samples_split_BrdU

#sample_stats will also be written, and contain how many reads were extracted for each sample and the file name for that run ID
BrdU_samples_stats <- read.delim(paste0(baseDir, "/KRG091819_BC_stats.txt"), header = T, sep =  "\t")
head(BrdU_samples_stats)
```

###Trim 3 "not G" (DDD) and index (6nt) from the 5' end of reads **(wrapping  FASTX's fastx_trimmer)**
Trimming 5'-end adapter sequences using R-wrapped **fastx_trimmer** function from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_trimmer_usage).
**read_start**: read starts at this base, 10 (default);  **read_end** read ends at this base, NULL (default)
[CLIPflexR documentation](fastx_trimmer.html)

```{r trim,echo=FALSE,eval=TRUE}
BrdU_split_rm5 <- lapply(samples_split_BrdU, fastx_trimmer, read_start = 10)
BrdU_split_rm5
```

### Fastx_clipper **(wrapping FASTX's fastx_clipper)**
Trimming 3'-end adapter sequences using R-wrapped **fastx_clipper** function from [FASTX_toolkit](http://hannonlab.cshl.edu/fastx_toolkit/commandline.html#fastx_clipper_usage).
**adaptor**: clip this sequence from the 3'-end of reads, "GTGTCAGTCACTTCCAGCGG" (default); **length**: minimum read length, only keep reads with length equal or greater then this threshold, 18 (default).
[CLIPflexR documentation](fastx_clipper.html)

```{r BrdU_clip_3prime,echo=FALSE,eval=TRUE}
BrdU_split_rm5_rm3 <- lapply(BrdU_split_rm5, fastx_clipper, length = 18, adaptor="GTGTCAGTCACTTCCAGCGG")
BrdU_split_rm5_rm3
```
These reads are now ready to map to your genome

##Build a Bowtie2 genome index and align to genome using Rbowtie2.
Build Bowtie2 index of reference genome, AaegL5 in this vignette.
[Index documentation](bowtie2_index.html); see also [CTK processing vignette](StandardandBrdU_Processing_CTK_editJD.html)

Align reads to genome by bowtie.
**format**: format of input sequences, fasta (default) or fastq; **threads**: number of threads used, 1 (default); **maxMismatches**: number of mismatches allowed, 1 (default) or 0; **seedSubString**: length of seed substrings, 18 (default), must be >3 & <32; **report_k**: NULL, look for multiple alignments, report best (default), otherwise report up to n (integer) alignments per read.
[Alignment documentation](bowtie_align.html)

```{r make_genome_index_and_align,echo=TRUE,eval=TRUE}
#you will need to get the genome fasta of your organism and input the path to this fasta
genomeFasta <- paste0(baseDir, "/Aedes-aegypti-LVP_AGWG_CHROMOSOMES_AaegL5.fa")

#make index; this step may take a long time and is therefore commented out but shown to illustrate how to execute the function
#building the index only needs to be done the first time you map to a given genome

#genomeIndex <- bowtie2_index(genomeFasta)

#If your genome index is already made, you can simply point to the index
genomeIndex  <- paste0(baseDir, "Aedes-aegypti-LVP_AGWG_CHROMOSOMES_AaegL5")

#Here I am selecting just a few samples for illustrative purposes. To run all your samples, you would do:
#tomap <- c(BrdU_split_rm5_rm3, samples_split_std_rm5_rm3)
tomap <- c(BrdU_split_rm5_rm3[1:4], samples_split_std_rm5_rm3[1:4])  # all I am doing here is taking samples 1-4 for each set of processed files (BrdU and standard) for mapping
tomap

#map files to genome with default parameters: maxMismatches=1,seedSubString=18,threads=1,report_k=NULL
bams <- lapply(tomap, bowtie_align, genomeIndex)
bams
```

##Convert to beds, find peaks, and build count matrix

Convert to beds
[CLIPflexR documentation](bamtobed_index.html)

```{r bam_to_bed,echo=TRUE,eval=TRUE}
beds <- lapply(bams, bamtobed)
beds
```

##Make tag directories and findpeaks **(wrapping HOMER's MakeTagDirectory and findpeaks)**
Call significant peaks in each sample using R-wrapped **homer_peaks** from [HOMER makeTagDirectory](http://homer.ucsd.edu/homer/ngs/tagDir.html) &
[HOMER findpeaks](http://homer.ucsd.edu/homer/ngs/peaks.html).
**style**: type of HOMER peak calling, "factor" (default); **foldEnrichmentOverLocal**: fold enrichment over local tag count, 2 (default); **localSize**:region to check for local tag enrichment, 10000 (default); **strand**: find peaks using tags on "seperate" (default); **minDist**: minimum distance between peaks, 50 (default); **size**: peak size, 10 (default); **fragLength**: approximate fragment length, 10 (default);  **genomeSize**: NULL=2e9 (default, human or mouse), or set for your genome
[CLIPflexR documentation](homer_peaks.html)

```{r find_peaks,echo=TRUE,eval=TRUE}
#you may want to play with these parameters depending on your protein of interest, and ensure that coverage lines up with the peaks you have called
peaks <- lapply(beds, homer_peaks, fragLength=25)
```

##Make count matrix of peaks, starting with reading in HOMER peak files and making a matrix that indicated which peals were called in each sample

```{r convert_peaks_to_ranges,echo=TRUE,eval=TRUE}
#read in peak files and convert to GRanges
read_peaks <- lapply(peaks,function(x)read.delim(x,sep="\t",comment.char = "#",h=FALSE))
read_peaksGR <- lapply(read_peaks,
                       function(x)GRanges(x$V2,IRanges(x$V3,x$V4),strand = x$V5))
names(read_peaksGR) <- gsub( paste0(baseDir,"/"), "",  (unlist(peaks)))
read_peaksGRList <- GRangesList(read_peaksGR)
GRSet <- unlist(read_peaksGRList)
nGRSet <- reduce(GRSet)
peakmat <- do.call(cbind,lapply(read_peaksGRList,
                                function(x)
                                  nGRSet %over% x))
mcols(nGRSet) <- peakmat

#now you have a peakmat where rows are a reduced set of peaks (without an identifier for the time being), and each column  is whether or not the peak was called in that sample
head(peakmat)
```

##The next step is to countFromBed  to append the number of reads at each peak location, by sample
[CLIPflexR documentation](countFromBed.html)

```{r count_from_beds,echo=TRUE,eval=TRUE}
#defaults are: notStranded=TRUE,interFeature=FALSE
countmat <- lapply(beds,countFromBed,GR=nGRSet)
countmat <- do.call(cbind,countmat)
colnames(countmat) <- basename(unlist(beds))

#now bind nGRSet, a GRanges with peak ranges and TRUE/FALSE at each peak, with countmat, the number of reads at each peak
mcols(nGRSet) <- cbind(as.data.frame(mcols(nGRSet)),countmat)
peaksDF <- as.data.frame(nGRSet)
peaksDF$peakID <- paste0(peaksDF$seqnames, ":", peaksDF$start, "_", peaksDF$end, ":", peaksDF$strand)
head(peaksDF)

```

#now you have your count matrix - you can perform operations on sample groups to filter, visualize data, annotate your peaks, and more...
#more vignettes coming soon!
